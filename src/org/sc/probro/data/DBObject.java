package org.sc.probro.data;

import java.util.*;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.sql.Clob;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONWriter;

public abstract class DBObject {
	
	public static String asSQL(Object v) {
		if(v == null) { 
			return "NULL";
		} else if(v instanceof String) { 
			return String.format("'%s'", v.toString().replace(";", "\\;").replace("'", "\\'"));
		} else { 
			return v.toString();
		}
	}
	
	public static boolean isSubclass(Class<?> c1, Class<?> c2) {
		return c2.isAssignableFrom(c1);
	}
	
	public static boolean cleanSQL(String str) { 
		int idx = -1;
		while((idx = str.indexOf("'")) != -1) { 
			if(idx == 0 || str.charAt(idx-1) != '\\') { 
				return false;
			}
		}
		return true;
	}
	
	public DBObject() {}
	
	private static String readClob(Clob c) throws SQLException { 
		StringBuilder sb = new StringBuilder();
		Reader r = c.getCharacterStream();
		int charInt = -1;
		try {
			while((charInt = r.read()) != -1) { 
				sb.append((char)charInt);
			}
		} catch (IOException e) {
			e.printStackTrace(System.err);
		}
		return sb.toString();
	}
	
	public DBObject(ResultSet rs) throws SQLException { 
		ResultSetMetaData data = rs.getMetaData();

		for(int i = 1; i <= data.getColumnCount(); i++) { 
			String columnName = data.getColumnName(i).toLowerCase();
			try {
				Field f = getClass().getField(columnName);
				int mod = f.getModifiers();
				
				if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) { 
					Object value = rs.getObject(i);
					if(value instanceof Clob) { 
						Clob clob = (Clob)value;
						f.set(this, readClob(clob));
					} else { 
						f.set(this, value);
					}
				}
				
			} catch (NoSuchFieldException e) {
				e.printStackTrace(System.err);
			} catch (IllegalAccessException e) {
				e.printStackTrace(System.err);
			}
		}
	}
	
	public DBObject(JSONObject obj) throws SQLException {
		Iterator<String> keys = obj.keys();
		while(keys.hasNext()) { 
			String key = keys.next();
			try {
				Field f = getClass().getField(key);
				int mod = f.getModifiers();
				Class type = f.getType();
				
				if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) {
					if(isSubclass(type, String.class)) { 
						f.set(this, obj.getString(key));
					} else if (isSubclass(type, Integer.class)) { 
						f.set(this, obj.getInt(key));
					} else if (isSubclass(type, Double.class)) { 
						f.set(this, obj.getDouble(key));
					} else { 
						f.set(this, obj.get(key));
					}
				}
				
			} catch (NoSuchFieldException e) {
				e.printStackTrace(System.err);
				
			} catch (IllegalAccessException e) {
				e.printStackTrace(System.err);
				
			} catch (JSONException e) {
				e.printStackTrace(System.err);
			}
		}		
	}
	
	public void setFromString(String fieldName, String value) { 
		try {
			Field f = getClass().getField(fieldName);
			int mod = f.getModifiers();
			if(!Modifier.isPublic(mod) || Modifier.isStatic(mod)) { 
				throw new IllegalArgumentException(fieldName);
			}
			
			Class type = f.getType();
			if(isSubclass(type, String.class)) {
				f.set(this, value);
			} else if (isSubclass(type, Integer.class)) { 
				f.set(this, Integer.parseInt(value));
			} else if (isSubclass(type, Double.class)) { 
				f.set(this, Double.parseDouble(value));
			} else { 
				throw new UnsupportedOperationException(type.getSimpleName());
			}
			
		} catch (NoSuchFieldException e) {
			//e.printStackTrace(System.err);
			throw new IllegalArgumentException(fieldName);
		} catch (IllegalAccessException e) {
			throw new IllegalArgumentException(fieldName);
		}
	}
	
	public abstract boolean isAutoGenerated(String fieldName);
	public String getKey() { return null; }
	
	public String writeHTMLRowHeader() { 
		StringBuilder html = new StringBuilder();

		html.append(String.format("<tr class=\"header_%s\">", getClass().getSimpleName().toLowerCase())); 
		for(Field f : getClass().getFields()) { 
			int mod = f.getModifiers();
			if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) { 
				String name = f.getName();
				html.append(String.format("<th>%s</th>", name));
			}
		}
		html.append(String.format("</tr>")); 

		return html.toString();
	}
	
	public String writeHTMLObject(boolean asRow) {
		StringBuilder html = new StringBuilder();
		if(asRow) { 
			html.append(String.format("<tr class=\"obj_%s\">", getClass().getSimpleName().toLowerCase())); 
		} else {  
			html.append(String.format("<table class=\"obj_%s\">", getClass().getSimpleName().toLowerCase()));
		}
		for(Field f : getClass().getFields()) { 
			int mod = f.getModifiers();
			if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) { 
				String name = f.getName();
				try {
					String value = String.valueOf(f.get(this));

					if(!asRow) { 
						html.append(String.format("<tr class=\"field_%s\">", name.toLowerCase())); 
						html.append(String.format("<td>%s</td>", name));
					}  
					html.append(String.format("<td class=\"value_%s\">%s</td>", name.toLowerCase(), value));
					if(!asRow) { 
						html.append("</tr>"); 
					} 

				} catch (IllegalAccessException e) {
					e.printStackTrace(System.err);
				}
			}
		}
		if(asRow) { 
			html.append(String.format("</tr>")); 
		} else {  
			html.append("</table>");
		}
		return html.toString();
	}
	
	protected void writeJSONObjectContents(JSONWriter json) throws JSONException { 
		for(Field f : getClass().getFields()) { 
			int mod = f.getModifiers();
			if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) { 
				String name = f.getName();
				try {
					Object value = f.get(this);
					if(value != null) { 
						json.key(name);
						json.value(value);
					}
					
				} catch (IllegalAccessException e) {
					throw new JSONException(e);
				}
			}
		}		
	}
	
	public void writeJSONObject(JSONWriter json) throws JSONException { 
		json.object();
		writeJSONObjectContents(json);
		json.endObject();
	}
	
	public String saveString() { 
		StringBuilder sb = new StringBuilder();
		String tableName = getClass().getSimpleName().toUpperCase() + "S";
		
		String autoName = null;
		Integer autoValue = null;
		
		for(Field f : getClass().getFields()) { 
			int mod = f.getModifiers();
			
			if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) {
				if(isAutoGenerated(f.getName())) { 
					if(autoName != null) { 
						throw new IllegalStateException("More than one auto-generated field isn't supported.");
					}
					if(!isSubclass(f.getType(), Integer.class)) { 
						throw new IllegalStateException("Non-integer auto-generated fields aren't supported.");						
					}
					
					autoName = f.getName();
					try {
						autoValue = (Integer)f.get(this);
						if(autoValue == null) { 
							throw new IllegalStateException("NULL auto-generated fields aren't allowed.");
						}

					} catch (IllegalAccessException e) {
						e.printStackTrace();
					}
					
				} else { 
					Object value = null;
					try {
						value = f.get(this);
						if(value != null) { 
							if(sb.length() > 0) { sb.append(", "); }

							sb.append(String.format("%s=%s", f.getName(), asSQL(value)));
						}

					} catch (IllegalAccessException e) {
						e.printStackTrace();
					}
				}
			}
		}
		
		if(autoName == null) { 
			throw new IllegalStateException("Must have at least one key...");
		}
		
		return String.format("UPDATE %s SET %s WHERE %s=%d",
				tableName, sb.toString(), autoName, autoValue);
	}
	
	public String insertString() { 
		String tableName = getClass().getSimpleName().toUpperCase() + "S";
		StringBuilder fields = new StringBuilder();
		StringBuilder values = new StringBuilder();
		
		for(Field f : getClass().getFields()) { 
			int mod = f.getModifiers();
			if(!isAutoGenerated(f.getName()) && Modifier.isPublic(mod) && !Modifier.isStatic(mod)) { 
				try {
					Object value = f.get(this);
					String name = f.getName();
					
					if(fields.length() > 0) { 
						fields.append(", ");
						values.append(", ");
					}
					
					fields.append(name);
					values.append(asSQL(value));
					
				} catch (IllegalAccessException e) {
					e.printStackTrace(System.err);
				}
			}
		}
		
		String fieldString = fields.toString(), valueString = values.toString();
		return String.format("INSERT INTO %s (%s) VALUES (%s)", tableName, fieldString, valueString);
	}	
	
	public <T extends DBObject> Collection<T> loadByKey(String myFieldName, Class<T> cls, String otherFieldName, Statement stmt) throws SQLException { 
		LinkedList<T> keyed = new LinkedList<T>();
		
		try {
			Field myField = getClass().getField(myFieldName);
			Object myValue = myField.get(this);
			if(myValue == null) { throw new IllegalArgumentException(String.format("%s has null value", myFieldName)); }
			
			Field otherField = cls.getField(otherFieldName);
			Constructor<T> constructor = cls.getConstructor();
			Constructor<T> resultConstructor = cls.getConstructor(ResultSet.class);
			
			T template = constructor.newInstance();
			otherField.set(template, myValue);
			
			String queryString = template.queryString();
			ResultSet rs = stmt.executeQuery(queryString);
			while(rs.next()) {
				keyed.add(resultConstructor.newInstance(rs));
			}
			rs.close();
			
		} catch (NoSuchFieldException e) {
			throw new IllegalArgumentException(e.getMessage(), e);
		} catch (IllegalAccessException e) {
			throw new IllegalArgumentException(e);
		} catch (NoSuchMethodException e) {
			throw new IllegalArgumentException(e.getMessage(), e);
		} catch (InstantiationException e) {
			throw new IllegalArgumentException(e.getMessage(), e);
		} catch (InvocationTargetException e) {
			throw new IllegalArgumentException(e.getMessage(), e);
		}
		
		return keyed;
	}
	
	public String queryString() { 
		String tableName = getClass().getSimpleName().toUpperCase() + "S";
		StringBuilder where = new StringBuilder();
		
		for(Field f : getClass().getFields()) { 
			int mod = f.getModifiers();
			if(Modifier.isPublic(mod) && !Modifier.isStatic(mod)) { 
				try {
					Object value = f.get(this);
					if(value != null) { 
						String name = f.getName();

						if(where.length() > 0) { 
							where.append(" AND ");
						}

						where.append(String.format("%s=%s", name, asSQL(value)));
					}
					
				} catch (IllegalAccessException e) {
					e.printStackTrace(System.err);
				}
			}
		}
		
		String whereString = where.toString();
		return String.format("SELECT * FROM %s %s", tableName, 
				(whereString.length() > 0 ? String.format("WHERE %s", whereString) : ""));
	}
}
